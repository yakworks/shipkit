#!/usr/bin/env bash
# ---
# default functions to setup BUILD_VARS
# BUILD_VARS are used in the build.sh and a makefile.env is created
# that is imcluded at the start of the Makefile to share vars
# ---
set -euo pipefail # strict mode https://bit.ly/36MvF0T
source "$(dirname "${BASH_SOURCE[0]}")"/bashify/core
core.import "logr"
core.import "utils"
core.import "yaml"
core.import "init_db_env"
core.import "git_tools"
core.import "setVar"

# __dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" # get dir this script is in
# source "${_dir}/setVar"
# source "${_dir}/logr"; # start verbose 'init_env' will make it kick to console
# source "${_dir}/yaml"
# source "${_dir}/git_tools"
# source "${_dir}/utils"
# source "${_dir}/init_db_env"

# version.properties should be in root dir
if [ -e "version.properties" ]; then source version.properties; fi

# initializes the environment
function init_env {
  version=${version:-}
  [ "$version" ] && init_versions
  logr debug "init_env start with version $version"

  # if a developer has a local dotenv then bring it in
  parse_env_file ".env"

  # if build/vault/bot.env has been cloned this will import the vars
  parse_bot_env_file

  # check for a build.env
  parse_env_file "build.env"

  # if this is running in circle then this will normailze ENV variables to ours
  circle_init_env

  init_defaults # call before init_from_build_yml

  # if gradle project then this imports vars from the build.yml
  init_from_build_yml

  # defaults
  init_defaults # call again after init_from_build_yml

}

# makes sure defaults are setup
function init_defaults {
  # important to remeber that setVar registers the var in BUILD_VARS
  # but only sets the passed in value if the variable is unset or empty
  PROJECT_FULLNAME="${PROJECT_FULLNAME:-}" # default to empty if not set
  [ ! "$PROJECT_FULLNAME" ] && project_fullname_from_git_remote
  add_build_vars PROJECT_FULLNAME

  # defaults the project name to the part after last /, so if fullname is 'foo/bar' then project name will be 'bar'
  setVar PROJECT_NAME "${PROJECT_FULLNAME##*/}"
  setVar APP_NAME "${PROJECT_NAME}"
  # the dir where the app is, defaults to the root of the project
  setVar APP_DIR "."
  setVar APP_KEY "${APP_NAME}"

  # default the releasable branch pattern and changelog name
  setVar RELEASE_BRANCH_REGEX "master|main|release/.+"
  setVar RELEASE_CHANGELOG "CHANGELOG.md"
  if [[ "${ACTIVE_BRANCH:-}" && "${ACTIVE_BRANCH}" =~ ^(${RELEASE_BRANCH_REGEX})$ ]]; then
    setVar RELEASABLE_BRANCH "$ACTIVE_BRANCH"
  fi

  # shellcheck disable=SC2034
  IS_RELEASABLE=''
  if [[ "${RELEASABLE_BRANCH:-}" && $(bool "${IS_SNAPSHOT:-}") = false ]]; then
    setVar IS_RELEASABLE true
  fi

  # the dir where the app is, defaults to the root of the project
  setVar APP_DIR "."
  setVar APP_KEY "${APP_NAME}"

  # sets up defaults for PAGES if they are not setup already
  setVar PAGES_BUILD_DIR "$BUILD_DIR/gh-pages"
  setVar PAGES_BRANCH "gh-pages"

}

# sets up defaults vars for docker ninedb and dock builders
function init_from_build_yml {
  # if gradle
  if [ -e ./build.yml ]; then
    # creates the variables from build.yml, exclude certain keys that are for gradle only
    yaml.load "./build.yml" true "" "MAVEN|CODENARC|SPOTLESS"
    BUILD_VARS+=" ${YAML_VARS[*]} "

    set +u
    # special handling, kubernetes requires all lower case for names so we abide and lower APP_KEY
    # APP_KEY="${APP_KEY:-$(tolower "$APP_KEY")}"
    [ "$APP_KEY" ] && APP_KEY=$(tolower "${APP_KEY}")
    [ "$APP_DOCKER_URL" ] && APP_DOCKER_URL=$(tolower "$APP_DOCKER_URL")
    [ "$APP_KUBE_INGRESS_URL" ] && APP_KUBE_INGRESS_URL=$(tolower "$APP_KUBE_INGRESS_URL")
    [ "$APP_KUBE_DB_SERVICE_NAME" ] && APP_KUBE_DB_SERVICE_NAME=$(tolower "$APP_KUBE_DB_SERVICE_NAME")
    set -u
  fi
  return 0 # I don't understand why this is needed
}


# ---
# sets the version and sets up the other useful variables for that version such as
# VERSIONX_DOTLESS and the NINEDB_VERSION
# ---
function init_versions {
  # if nothing passing in the usee the lowercase version that should have come in from version.properties
  # local ver=${1:-$version}
  setVar VERSION "$version"
  setVar PUBLISHED_VERSION "${publishedVersion:-}"

  # shellcheck disable=SC2153 # Possible misspelling
  # cuts to the last dot
  local baseVersion="${VERSION%.*}"

  # VERSIONX is used for docker and k8s as we deploy latests minor version
  # also used to connect to the latest compatible database when that is relevant
  setVar VERSIONX "$baseVersion.x"
  #replace dots with - so 10.0.x turns into v10-0-x. k8s can't have dots in names
  setVar VERSIONX_DOTLESS "v${VERSIONX//./-}"

  putVar BUILD_VERSION "$VERSION"

  # if its a snapshot then append the SNAPSHOT
  if truthy "${snapshot:-}"; then
    putVar VERSION_POSTFIX "-SNAPSHOT"
    putVar IS_SNAPSHOT true
    BUILD_VERSION+="-SNAPSHOT"
    VERSIONX_DOTLESS+="-SNAPSHOT"
  fi

  return 0
}

# Checks for CIRCLECI and normalizes some ENV vars that are availiable
function circle_init_env {
  CIRCLECI="${CIRCLECI:-}" # default to empty
  # if CIRCLE_BRANCH is set then consider it setup
  if [ "$CIRCLECI" ]; then
    setVar CI true
    setVar ACTIVE_BRANCH "$CIRCLE_BRANCH"
    setVar PROJECT_FULLNAME "${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}"
    # setVar GIT_REPO_URL "$CIRCLE_REPOSITORY_URL"
  fi
}

# main make env, this is called early shipkit or can be overriden in build.sh.
# $1 - BUILD_ENV (test, dev, seed)
function make_env {
  make_env_init "${1:-}"
  createEnvFile
}

# create build/make_env_db.env for importing into makefile.
# $1 - BUILD_ENV (test, dev, seed)
function make_env_init {
  setVar BUILD_ENV "${1:-test}"
  init_env
  init_db_env  #if DBMS env is set
}

# create env file from BUILD_VARS for importing into makefile.
function createEnvFile {
  local env_file="$MAKE_ENV_FILE" # exported from shipkit-main
  local env_file_dir="$(dirname "$env_file")"
  mkdir -p "$env_file_dir"

  echo "# ----- Generated from build.sh --------" > "$env_file"
  for varName in $BUILD_VARS; do
      val=${!varName}
      echo "$varName=$val" >> "$env_file"
  done
  echo "BUILD_VARS=$BUILD_VARS" >> "$env_file"
  echo "created $env_file"
}

# looks for build/vault/bot.env file and loads it in if its there
# normally the flow for CI would be as an early step to clone the git project with the file there
# then do the process for "git secret reveal" to decrypt it.
# this is then called in the normal init_env process from projects build.sh
# right now the default is to parse bot.env and have its varibale OVERRIDE all others in the environment
function parse_bot_env_file {
  local bot_env="build/vault/bot.env"
  if [ -f $bot_env ]; then
    #change this once we have it sqaured away so exported env vars always win
    parse_env_file $bot_env true
  fi
}

# looks for .env file in root of project
function parse_user_env_file {
  local env_file=".env"
  if [ -f $bot_env ]; then
    #change this once we have it sqaured away so exported env vars always win
    parse_env_file $bot_env true
  fi
}

# parses the env file, eval and load into BUILD_VARS
# $1 - the env file to parse
# $2 - true if we want to override all variables that might already be set
function parse_env_file {
  local env_file="${1}"
  local overrideVar="${2:-false}"

  # check if file exists, and return if not
  if [ ! -f "$env_file" ]; then
    return 0
  fi

  local lines=$(cat "$env_file")
  local line key
	while IFS= read -r line; do
    # trim leading whitespace
		line=${line#"${line%%[![:space:]]*}"}
    # trim trailing whitespace
		line=${line%"${line##*[![:space:]]}"}
    # move on if its a comment
		if [[ ! "$line" || "$line" == '#'* ]]; then continue ; fi
    # echo "line $line"
    key="${line%%=*}"
    val="${line#*=}"
    if truthy "$overrideVar" ; then
      putVar "$key" "$val"
    else
      setVar "$key" "$val"
    fi
	done <<<"$lines"
  # log-vars
}




# --- boiler plate function runner, keep at end of file ------
# BASH_SOURCE check will be true if this is run, false if imported into another script with `source`
if [[ "${#BASH_SOURCE[@]}" == 1 ]]; then
  source "${BASHIFY_PATH}/function_runner.sh"
fi

